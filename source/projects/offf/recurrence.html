<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>OFFF artists by industry</title>
        <script type="text/javascript" src="/offf/library/d3.js"></script>
        <link rel="stylesheet" type="text/css" href="/offf/stylesheets/mainstyle.css">
        <script src="/offf/library/jquery-2.2.0.min.js" type="text/javascript" > </script>

    </head>


    <body>
      

    <script>
      var
          width = window.innerWidth,
          height = window.innerHeight;

      // SVG selection that holds the visualization
      var svg = d3.select("body").append("svg")
          // .attr("width", width)
          // .attr("height", height)
          .attr("id", "container")
          .attr("viewBox", "0 0 " + width + " " + height) //viewbox
          .append("g")
          .attr("preserveAspectRatio", "xMidYMid meet");


      // force layout, used to calculate positions
      var force = d3.layout.force()
        .linkDistance(50)
        .linkStrength(0.25)
        .charge(-125)
        .size([width, height])
        .on("tick", tick);

      // this global will hold the loaded data
      var graph;

      // and these will hold the SVG elements
      var nodeSelection = svg.selectAll('.node');
          linkSelection = svg.selectAll('.link');

      // lookup arrays for styling
      var color = ["blue", "white", "red","#f3aa84", "#e66964", "#f6c831"];
      var radius = ["100","100","100","4","4","4"]; // the first three shouldn't happen
      var transparency = ["0","0","0","0","0","0"];

      // filter values
      var includeGroupyears = [3,4,5];
      var includeGroupstatus = [3,4,5];
      var includeGroupcontinent = [3,4,5,6,7,8];

      // load and tick the layout, then draw all the things
      function draw() {

        // get them from the loaded graph
        var allNodes = graph.nodes.slice(); // slice forces a copy
            rawLinks = graph.links.slice();

        // we have to find nodes ourself, because d3.force.links expects objects or indexes.
        var allLinks = rawLinks.map(function(link) {
          var source = allNodes.find(function(node){ return node.id === link.source; });
          var target = allNodes.find(function(node){ return node.id === link.target; });
          return {source: source, target: target, stroke: link.stroke};
        });

console.log("allLinks", allLinks);

        // pre-start to force allLinks to reference nodes
        // force
        //   .nodes(allNodes)
        //   .links(allLinks)
        //   .start();

        var filteredNodes = allNodes.filter(filterNode),
            nodeIds = filteredNodes.map(function(node){return node.id}),
            filteredLinks = trimLinks(allLinks, nodeIds);

        // console.log("Filtered links", allLinks, filteredLinks, graph);

        // start the layout ticking
        force
          .nodes(filteredNodes)
          .links(filteredLinks)
          .start();

        // bind the data array to the svg selection
        linkSelection = linkSelection.data(filteredLinks);

        // draw new links
        linkSelection.enter().append("path")
          .attr("class", "link") // you have to do this or you can't re-select it!
          .style("opacity", "0.2")
          .style("stroke-width", function(d,s) {return d.stroke;})
          .style("stroke", "#FFFFFF")
          .style("fill", "none");

        // remove old links
        linkSelection.exit().remove();

        // bind the data array to the svg selection, with a key function
        nodeSelection = nodeSelection.data(filteredNodes, function(d) { return d.id; });

        // draw new nodes
        var node = nodeSelection.enter()
          .append("g")
          .call(force.drag);

        node.append("circle")
          .attr("class", "node") // you have to do this or you can't re-select it!
          .attr("fill", function(d, i) {return d.groupyear ? color[d.groupyear] : "white";}) // if no groupyear, then it's a category, so color white
          .style("r", function(d, i) {return d.groupyear ? radius[d.groupyear] : 7;}) // if no groupyear, then it's a category, so size 7
          .style("fill", function(d, i) {return color[d.groupyear]});


        node.append("text")
          .attr("dx", 8)
          .attr("dy", 4)
          .attr("spacing", 16)
          .attr("id", "abc")
          .attr("fill", function(d, i) {return d.groupyear ? color[d.groupyear] : "white";}) // if no groupyear, then it's a category, so color white
          .attr("opacity", function(d, i) {return d.groupyear ? transparency[d.groupyear] : 1;}) // if no groupyear, then it's a category, so opacity 1
          .attr("opacity", function(d, i) {return transparency[d.groupyear]})
          .text(function(d) {return d.name});


        // remove old nodes
        nodeSelection.exit().remove();
      }

      // called by force layout during iteration
      function tick() {
        linkSelection.attr("d", arcPath);
        nodeSelection
        .attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        });
      }

      // draw SVG arc for link _d_, per http://bl.ocks.org/mbostock/1153292
      function arcPath(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
      }

      // apply filters
      function filterNode(node) {
        return ((typeof node.groupyear == "undefined") || includeGroupyears.includes(node.groupyear));
      }

      function trimLinks(links, nodeIds) {
        results = [];
        var results = links.filter(function(link) {
          return (nodeIds.includes(link.source.id) && nodeIds.includes(link.target.id));
        });
        return results;
      }

      // fetch data and (in the callback) load into the arrays
      d3.json("/offf/data/industry.json", function(error, json) {
        graph = json;
        console.log('Fetched', graph);
        draw();
      });

      // wire up the filters the hard way
      d3.select("#year1").on("click", function() { includeGroupyears = [1,3]; draw(); });
      d3.select("#year2").on("click", function() { includeGroupyears = [1,4]; draw(); });
      d3.select("#year3").on("click", function() { includeGroupyears = [1,5]; draw(); });
      d3.select("#year4").on("click", function() { includeGroupyears = [1,3,4,5]; draw(); });


      d3.select("#label0").on("click", function(d,i) {
        // Determine if current label is visible
         var active   = abc.active ? false : true,
           newOpacity = active ? 1 : 0;
         // Hide or show the labels
         d3.selectAll("text").attr("opacity", newOpacity);
         d3.selectAll("text").select("id", "abc").attr("opacity", newOpacity);
         // Update whether or not the elements are active
         abc.active = active;
       });

    </script>
